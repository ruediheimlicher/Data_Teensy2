/*----------------------------------------------------------------------*/
/* FAT file system sample project for FatFs            (C)ChaN, 2014    */
/*----------------------------------------------------------------------*/


#include <avr/io.h>
#include <avr/interrupt.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "uart.h"
#include "xitoa.h"
#include "ff.h"
#include "diskio.h"
#include "rtc.h"
#include <avr/pgmspace.h>
#include "cfc_avr.c"
#include "integer.h"

//FUSES = {0xF7, 0x91, 0xFC};
/* ATmega1284p fuses: Low, High, Extended.
This is the fuse settings for this project. The fuse bits will be included
in the output hex file with program code. However some old flash programmers
cannot load the fuse bits from hex file. If it is the case, remove this line
and use these values to program the fuse bits. */




BYTE Buff[4096];	/* Working buffer */

FATFS FatFs[2];		/* File system object for each logical drive */
FIL File[2];		/* File object */
DIR Dir;			/* Directory object */
FILINFO Finfo;
DWORD AccSize;				/* Work register for fs command */
WORD AccFiles, AccDirs;

BYTE RtcOk;				/* RTC is available */

//volatile unsigned int Timer;	/* Performance timer (100Hz increment) */



/*---------------------------------------------------------*/
/* User Provided Timer Function for FatFs module           */
/*---------------------------------------------------------*/
/* This is a real time clock service to be called from     */
/* FatFs module. Any valid time must be returned even if   */
/* the system does not support a real time clock.          */
/* This is not required in read-only configuration.        */


DWORD get_fattime (void)
{
	RTC rtc;


	if (!RtcOk) return 0;

	/* Get local time */
	rtc_gettime(&rtc);

	/* Pack date and time into a DWORD variable */
	return	  ((DWORD)(rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
			| ((DWORD)rtc.hour << 11)
			| ((DWORD)rtc.min << 5)
			| ((DWORD)rtc.sec >> 1);
}



/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC0A                 */
/*---------------------------------------------------------*/


ISR(TIMER0_COMPA_vect)
{
	Timer++;			/* Performance counter for this module */
	cf_disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
}



/*--------------------------------------------------------------------------*/
/* Monitor                                                                  */


static
void put_dump (const BYTE *buff, DWORD ofs, BYTE cnt)
{
   /*
	BYTE i;


	printf(PSTR("%08lX:"), ofs);

	for(i = 0; i < cnt; i++)
		printf(PSTR(" %02X"), buff[i]);

	xputc(' ');
	for(i = 0; i < cnt; i++)
		xputc((buff[i] >= ' ' && buff[i] <= '~') ? buff[i] : '.');

	xputc('\n');
    */
}


static
void get_line (char *buff, int len)
{
	BYTE c;
	int i = 0;
/*

	for (;;) {
		c = uart_getc();
		if (c == '\r') break;
		if ((c == '\b') && i) {
			i--;
			uart_putc(c);
			continue;
		}
		if (c >= ' ' && i < len - 1) {	// Visible chars
			buff[i++] = c;
			xputc(c);
		}
	}
	buff[i] = 0;
	xputc('\n');
 */
}


static
FRESULT scan_files (
	char* path		// Pointer to the working buffer with start path
)
{
	DIR dirs;
	FRESULT fr;
	int i;
/*
	fr = f_opendir(&dirs, path);
	if (fr == FR_OK) {
		while (((fr = f_readdir(&dirs, &Finfo)) == FR_OK) && Finfo.fname[0]) {
			if (Finfo.fattrib & AM_DIR) {
				AccDirs++;
				i = strlen(path);
				path[i] = '/'; strcpy(path+i+1, Finfo.fname);
				fr = scan_files(path);
				path[i] = 0;
				if (fr != FR_OK) break;
			} else {
//				xprintf(PSTR("%s/%s\n"), path, Finfo.fname);
				AccFiles++;
				AccSize += Finfo.fsize;
			}
		}
	}
*/
	return fr;
}



static
void put_rc (FRESULT rc)
{
	const char* PROGMEM *p;
	 const char* PROGMEM str[] =
   {"OK\0DISK_ERR\0INT_ERR\0NOT_READY\0NO_FILE\0NO_PATH\0INVALID_NAME\0"
		"DENIED\0EXIST\0INVALID_OBJECT\0WRITE_PROTECTED\0INVALID_DRIVE\0"
		"NOT_ENABLED\0NO_FILE_SYSTEM\0MKFS_ABORTED\0TIMEOUT\0LOCKED\0"
		"NOT_ENOUGH_CORE\0TOO_MANY_OPEN_FILES\0"};
	FRESULT i;

	for (p = str, i = 0; i != rc && pgm_read_byte_near(p); i++) {
		while(pgm_read_byte_near(p++));
	}
	printf(PSTR("rc=%u FR_%S\n"), rc, p);
}




static
void ioinit (void)
{
	MCUCR = _BV(JTD); MCUCR = _BV(JTD);	/* Disable JTAG */

	/* Start 100Hz system timer with TC0 */
	OCR0A = F_CPU / 1024 / 100 - 1;
	TCCR0A = _BV(WGM01);
	TCCR0B = 0b101;
	TIMSK0 = _BV(OCIE0A);

	sei();
}



/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int mainfkt (void)
{
	char line[120];
	char *ptr, *ptr2;
	long p1, p2, p3;
	FRESULT fr;
	BYTE b1, *bp;
	UINT s1, s2, cnt, blen = sizeof Buff;
	DWORD ofs, sect = 0;
	FATFS *fs;
	RTC rtc;


	ioinit();				/* Initialize port settings and start system timer process */
#ifdef DRV_CFC
	xprintf(PSTR("CFC ==> %u\n"), DRV_CFC);
#endif
#ifdef DRV_MMC
	xprintf(PSTR("MMC ==> %u\n"), DRV_MMC);
#endif

/*
	if (rtc_init() && rtc_gettime(&rtc)) {		// Initialize RTC
		RtcOk = 1;
		xprintf(PSTR("Current time: %u/%u/%u %02u:%02u:%02u\n"), rtc.year, rtc.month, rtc.mday, rtc.hour, rtc.min, rtc.sec);
	} else {
		xputs(PSTR("RTC is not available.\n"));
	}
*/

	for (;;) {
		ptr = line;

		get_line(ptr, sizeof line);
		switch (*ptr++)
      {
			break;


		}// switch
	}

}

